https://leetcode.com/problems/majority-element-ii/description/

using map
Count occurrences using a map and return elements with freq > n/3.

‚è± Complexity

Time: O(n)

Space: O(n)
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) 
    {
        vector<int> res;
        int n=nums.size();

        unordered_map<int,int> mp;

        for(auto ele:nums)
        {
            mp[ele]++;
        }

        for(auto ele:mp)//iterate map 
        {
            if(ele.second > n/3)
            {
                res.push_back(ele.first);
            }
        }
        return res;
    }
};

*****
moore voting algo

üß† Key Observation

For > n/3:

There can be at most 2 majority elements

Use 2 candidates + 2 counters


vector<int> majorityElement(vector<int> v) 
{
	vector<int> res; //max 2 ele can be answer 
	//to use moores algo use 2 cand and 2 counts
	int can1 = INT_MIN,can2 = INT_MIN; //initilise by INT_MIN wont work if array has 0 as ele ****************
	int cnt1 = 0,cnt2 = 0;
	int n = v.size();

	for(auto ele:v)
	{
		if(cnt1 == 0 && ele != can2)//both cand different  
		{
			can1 = ele;
			cnt1++;
		}
		else if(cnt2 == 0 && ele!=can1)//both cand different 
		{
			can2 = ele;
			cnt2++;
		}
		else if(ele == can1) cnt1++;
		else if(ele == can2) cnt2++;
		else
		{
			cnt1--;
			cnt2--;
		}
	}

	//validate res 
	cnt1 = 0;
	cnt2 = 0;

	for(auto ele:v)
	{
		if(ele == can1) cnt1++;
		else if(ele == can2) cnt2++;
	}

	if(cnt1 > n/3) res.push_back(can1);
	if(cnt2 > n/3) res.push_back(can2);

	return res;

}
