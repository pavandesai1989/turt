https://leetcode.com/problems/permutation-in-string/description/

***brute force****
class Solution {
public:
    bool checkInclusion(string s1, string s2) 
    {
        int len1=s1.length();
        sort(s1.begin(),s1.end()); //sort s1

        for(int i=0;i<s2.length();i++)
        {
            string sub = s2.substr(i,len1); //sort substr of s2 of len s1
            sort(sub.begin(),sub.end());
            if(sub == s1) return true;
        }
        return false;
    }
};

O(m log m) + O(n * m log m)
≈ O(n * m log m)

***** better avoid sorting****
class Solution {
public:
    bool checkInclusion(string s1, string s2) 
    {
        //how can i avoid sorting
        unordered_map<char,int> mpp1;
        unordered_map<char,int> mpp2;

        for(auto& ele:s1)
        {
            mpp1[ele]++;
        }

        int l1=s1.length();
        int l2=s2.length();

        for(int i=0;i<=l2-l1;i++)
        {
            unordered_map<char,int> mpp2;
            for(int j=i;j-i<l1;j++)
            {
                mpp2[s2[j]]++;
            }

            if(mpp1 == mpp2)
            {
                return true;
            }
        }
        return false;
    }
};

(l2 − l1 + 1) times  →  O(l2 − l1)

Space = O(l1)


********optimal****
ALGO:
Algorithm: Sliding Window + HashMap
Problem

Check if s2 contains a permutation of s1.

Permutation → same character counts as s1.

Key Idea

Use a sliding window of size s1.length() over s2.

Keep track of character counts in the current window (m2) and in s1 (m1).

If m1 == m2, we have a valid permutation.

Steps

Initialize

m1 → count chars of s1.

i = 0, j = 0 → sliding window pointers.

m2 → count chars in current window of s2.

Expand Window

Add s2[j] to m2.

Check Window Size

If window size equals s1.length():

Compare m1 and m2.

If equal → return true.

Shrink window from left:

m2[s2[i]]--

If m2[s2[i]] == 0, erase the key.

Increment i.

Increment j → continue sliding.

Return false if no permutation found.

*******************

class Solution {
public:
    bool checkInclusion(string s1, string s2) 
    {
        int m = s1.length();
        int n = s2.length();

        //as we need to find permutation need to store the char counts. use maps
        unordered_map<int,int> m1; //stores char of s1
        unordered_map<int,int> m2; //stores char of s2

        //store all char of s1 in m1
        for(auto ele:s1)
        {
            m1[ele]++;
        }

        //we need to compare maps when we have length of s1. to find length we need i and j
        int i=0;
        int j=0;

        //we need to find out if s1 is in s2. so iterate through n
        while(j<n)
        {
            //add freq in m2
            m2[s2[j]]++;

            //if length exceeds length of s1. reduce count of char of i from s2
            if(j-i+1 > m)
            {
                //reduce length  of window
               m2[s2[i]]--;

               //if o erase 
               if(m2[s2[i]]==0)
               {
                m2.erase(s2[i]);
               }
               i++;
            }

            //when length same check if both maps same 
            if(j-i+1 == m)
            {
                if(m1 == m2) return true;
            }
            j++;
        }
        return false;
    }
};
