//https://leetcode.com/problems/k-closest-points-to-origin/description/

class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) 
    {
        vector<vector<int>> res;
        priority_queue < pair<double,vector<int> >, 
                        vector< pair<double,vector<int> >  >, 
                        less< pair<double,vector<int> >>   >  minheap;
        /*note to take double for the sqrt  */

        for(int i=0;i<points.size();i++) //time is o(n) * (logk) //space o(k)
        {
            int x = points[i][0];
            int y = points[i][1];

            vector<int> vec({x,y});
            double val = sqrt((x*x) + (y*y));

            minheap.push(make_pair(val,vec));
            if(minheap.size() > k)minheap.pop();
        }

        while(!minheap.empty()) //o(k)* log(k)
        {
            int x = minheap.top().second[0];
            int y = minheap.top().second[1];

            res.push_back({x,y});
            minheap.pop();
        }
        return res;
    }
};
